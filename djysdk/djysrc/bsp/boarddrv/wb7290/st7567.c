//-----------------------------------------------------------------------------
// Copyright (C) 2012-2020 长园继保自动化有限公司 All Rights Reserved
// 文件名     ：st75320.c
// 模块描述: 液晶模块的初始化及显示驱动
// 模块版本: V1.00
// 创建人员: HM
// 创建时间: 3/19.2016
// =============================================================================

#if 1
#include <stdint.h>
#include <stddef.h>

#include "os.h"
#include "cpu_peri.h"
#include <string.h>

//#define GPIO_IO

#ifdef GPIO_IO

//CS PC14;
#define	LCD_CS_0()	PIOC->PIO_CODR =(1<<14);
#define	LCD_CS_1()	PIOC->PIO_SODR =(1<<14);

//RS PC18;
#define	LCD_RS_0()	PIOC->PIO_CODR =(1<<18);
#define	LCD_RS_1()	PIOC->PIO_SODR =(1<<18);

//WE PC8;
#define	LCD_WR_0()	PIOC->PIO_CODR =(1<<8);
#define	LCD_WR_1()	PIOC->PIO_SODR =(1<<8);

//RD PC11;
#define	LCD_RD_0()	PIOC->PIO_CODR =(1<<11);
#define	LCD_RD_1()	PIOC->PIO_SODR =(1<<11);

//RST ;
#define	LCD_RES_0()
#define	LCD_RES_1()

//PC[7:0]
#define	LCD_BUS		PIOC->PIO_ODSR

#define LCD_D0_D7       (0xFF)
#define LCD_RS          (PIO_PC18)
#define LCD_RD          (PIO_PC11)
#define LCD_WR          (PIO_PC8)
#define LCD_NCS         (PIO_PC14)


// =============================================================================

static void set_lcd_dat(u8 dat)
{
	Pio *pio;
	u32 bak;

	pio=PIOC;
	bak=pio->PIO_OWER;;

	pio->PIO_OWER |=0x000000FF;	//只写PC[7:0]
	pio->PIO_ODSR =dat;

	pio->PIO_OWER =bak;

}

static u8 get_lcd_dat(void)
{
	Pin pin;
	u8 dat;
	Pio *pio;

	pio =PIOC;

	//设置为输入模式．
	pin.mask =0x0000000FF;//PC[7:0]
	pin.pio  =PIOC;
	pin.id   =ID_PIOC;
	pin.type =PIO_INPUT;
	pin.attribute =PIO_OPENDRAIN;
	PIO_Configure(&pin,1);

	pio->PIO_PER |= 0x000000FF;
	dat =pio->PIO_PDSR;

	//设置回输出模式．
	pin.mask =0x000000FF; //PC[7:0]
	pin.pio  =PIOC;
	pin.id   =ID_PIOC;
	pin.type =PIO_OUTPUT_1;
	pin.attribute =PIO_DEFAULT;
	PIO_Configure(&pin,1);
	return dat;

}
static void Lcd_WriteCommand(u8 Cmd)
{
	set_lcd_dat(Cmd);
	LCD_RS_0();
	LCD_CS_0();
	LCD_RD_1();
	LCD_WR_0();

	Djy_DelayUs(1);		//needed
	LCD_WR_1();
	LCD_CS_1();
}

static void Lcd_WritdData(u8 Data)
{
	set_lcd_dat(Data);
	LCD_RS_1();
	LCD_CS_0();
	LCD_RD_1();
	LCD_WR_0();

	Djy_DelayUs(1);//needed
	LCD_WR_1();
	LCD_CS_1();
}

void Lcd_WriteSpecialCmd(u8 Cmd)
{
	set_lcd_dat(Cmd);
	LCD_RS_0();
	LCD_CS_0();
	LCD_RD_0();
	LCD_WR_0();

	Djy_DelayUs(1);		//needed
	LCD_WR_1();
	LCD_CS_1();
}

static u8 Data_Get(void)
{
	u8 data;

	LCD_RS_1();
	LCD_CS_0();
	LCD_WR_1();
	LCD_RD_0();

	data = get_lcd_dat();
	LCD_RD_1();
	LCD_CS_1();

	return data;
}

void Lcd_PortInit(void)
{
	Pin pin;
	Pio *pio=PIOC;

	PMC_EnablePeripheral(ID_PIOA);
	PMC_EnablePeripheral(ID_PIOB);
	PMC_EnablePeripheral(ID_PIOC);
	PMC_EnablePeripheral(ID_PIOD);

	////LCD BackLight: PD23,0:ON,1:OFF
	pin.mask =PIO_PD23;
	pin.pio  =PIOD;
	pin.id   =ID_PIOD;
	pin.type =PIO_OUTPUT_1;
	pin.attribute =PIO_PULLUP;
	PIO_Configure(&pin,1);
	PIO_Clear(&pin);  //Backlight ON.
	PIO_Set(&pin);

	////LCD CS: PIO_PC14
	pin.mask =PIO_PC14;
	pin.pio  =PIOC;
	pin.id   =ID_PIOC;
	pin.type =PIO_OUTPUT_1;
	pin.attribute =PIO_PULLUP;
	PIO_Configure(&pin,1);

	////LCD RS: PIO_PC18
	pin.mask =PIO_PC18;
	pin.pio  =PIOC;
	pin.id   =ID_PIOC;
	pin.type =PIO_OUTPUT_1;
	pin.attribute =PIO_PULLUP;
	PIO_Configure(&pin,1);

	////LCD WR: PC8
	pin.mask =PIO_PC8;
	pin.pio  =PIOC;
	pin.id   =ID_PIOC;
	pin.type =PIO_OUTPUT_1;
	pin.attribute =PIO_PULLUP;
	PIO_Configure(&pin,1);

	////LCD RD: PC11
	pin.mask =PIO_PC11;
	pin.pio  =PIOC;
	pin.id   =ID_PIOC;
	pin.type =PIO_OUTPUT_1;
	pin.attribute =PIO_PULLUP;
	PIO_Configure(&pin,1);

	////LCD DAT: PC[7:0]
	pin.mask =LCD_D0_D7;
	pin.pio  =PIOC;
	pin.id   =ID_PIOC;
	pin.type =PIO_OUTPUT_0;
	pin.attribute =PIO_PULLUP;
	PIO_Configure(&pin,1);

	pio =PIOC;
	pio->PIO_OER   =0xFF;
}

#else

#define LCD_DATA_ADDR			(EBI_CS0_ADDR+0x1)		//此LCD芯片写数据是高电平
#define LCD_COMMAND_ADDR		(EBI_CS0_ADDR)			//写命令是低电平
#define LCD_COMMAND_MODE		(0x00)
#define LCD_DATA_MODE			(0x01)

//EBI Data Bus pins
#define PIN_EBI_DBUS			{0xFF,PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}
//EBI pins for address bus
//#define PIN_EBI_ABUS			{0x1f<<18,PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}//注意地址总线
#define PIN_EBI_ABUS0			{1<<18,PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}//
#define PIN_EBI_ABUS1			{1<<19,PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}//
#define PIN_EBI_ABUS2			{1<<20,PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}//
#define PIN_EBI_ABUS3			{1<<21,PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}//
#define PIN_EBI_ABUS4			{1<<22,PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}//

//EBI NRD pin(PC11)
#define PIN_EBI_DNRD			{1<<11, PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}
//EBI NWE pin(PC8)
#define PIN_EBI_DNWE			{1<<8,  PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}
//EBI NCS0 pin(PC14)
#define PIN_EBI_ENCS0			{1<<14, PIOC,ID_PIOC,PIO_PERIPH_A,PIO_PULLUP}//XCS1 nCS0 pin

//PIN_LCD_BACKLIGHT
#define PIN_LCD_BACKLED			{PIO_PD23, PIOD,ID_PIOD,PIO_OUTPUT_0,PIO_PULLUP}

static const Pin LCD_Pins[] = {
	PIN_EBI_DBUS,
	PIN_EBI_DNRD,
	PIN_EBI_DNWE,
	PIN_EBI_ABUS0,
	PIN_EBI_ENCS0,
	PIN_LCD_BACKLED,
};
static void Lcd_PortInit(void)
{
	PIO_Configure(LCD_Pins,PIO_LISTSIZE(LCD_Pins));
	PMC_EnablePeripheral(ID_SMC ) ;

	SMC->SMC_CS_NUMBER[0].SMC_SETUP = (0
					| (SMC_SETUP_NWE_SETUP(40))
					| (SMC_SETUP_NCS_WR_SETUP(20))
					| (SMC_SETUP_NRD_SETUP(40))
					| (SMC_SETUP_NCS_RD_SETUP(20))
					  );

	SMC->SMC_CS_NUMBER[0].SMC_PULSE = (0
					| (SMC_PULSE_NWE_PULSE(50))
					| (SMC_PULSE_NCS_WR_PULSE(80))

					| (SMC_PULSE_NRD_PULSE(50))
					| (SMC_PULSE_NCS_RD_PULSE(80))
					  );

	SMC->SMC_CS_NUMBER[0].SMC_CYCLE = (0
					| (SMC_CYCLE_NWE_CYCLE(150))
					| (SMC_CYCLE_NRD_CYCLE(150))
					  );

	SMC->SMC_CS_NUMBER[0].SMC_MODE = (0
					| (SMC_MODE_DBW_8_BIT)
					| (SMC_MODE_EXNW_MODE_DISABLED)
					| (SMC_MODE_BAT_BYTE_WRITE)
					| (SMC_MODE_READ_MODE)
					| (SMC_MODE_WRITE_MODE)
					  );
}

static void Lcd_WriteCommand(uint8_t cmd)
{
//	Djy_DelayUs(1);

	*(volatile u8*)LCD_COMMAND_ADDR = cmd;
}

static void Lcd_WritdData(uint8_t u8Data)
{
//	Djy_DelayUs(2);
	*(volatile u8*)LCD_DATA_ADDR = u8Data&0x000000ff;
}

#endif

static struct SemaphoreLCB *pLcdCtrlSync;

const uint8_t g_byIcon_szn[ ] =
{
/*------------------------------------------------------------------------------
  宽×高（像素）: 128×64
  字模格式/大小 : 单色点阵液晶字模，横向取模，字节正序/1024字节
  数据转换日期  : 2012/12/3 10:44:23
------------------------------------------------------------------------------*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x3E,0x0F,0x80,0x0F,0x80,0x0F,0xE0,0x00,0x3F,0xFF,0x8F,0xEE,0x30,0xC0,
0x00,0x00,0xFF,0x0F,0xC0,0x1F,0x80,0x3F,0xF8,0x08,0x3F,0xFF,0x8F,0xEE,0x30,0xC0,
0x00,0x03,0xFF,0x87,0xC0,0x1F,0x00,0xFF,0xFC,0x0E,0x3F,0xFF,0x8F,0xEE,0x30,0xC0,
0x00,0x0F,0xFF,0x83,0xE0,0x3E,0x01,0xFF,0xFE,0x0E,0x3F,0xFF,0x8F,0xEE,0x30,0xC0,
0x00,0x1F,0xFF,0x83,0xE0,0x3E,0x03,0xF0,0x0E,0x0F,0x37,0x39,0x81,0x8F,0xFF,0xC0,
0x00,0x3C,0x0F,0x81,0xF0,0x7C,0x07,0xE0,0x06,0x03,0x37,0x1D,0x81,0x8F,0xFF,0xC0,
0x00,0x70,0x07,0x01,0xF0,0x7C,0x0F,0xC0,0x02,0x01,0x0E,0x1D,0x81,0x80,0x00,0x00,
0x00,0xE0,0x02,0x00,0xF8,0xF8,0x1F,0x80,0x00,0x08,0x0E,0x1E,0x01,0x80,0x00,0x00,
0x01,0xC0,0x00,0x00,0xF8,0xF8,0x1F,0x00,0x00,0x08,0x0E,0x0E,0x01,0x80,0x00,0x00,
0x03,0x80,0x00,0x00,0x7D,0xF0,0x3E,0x00,0x00,0x0F,0x3C,0xE7,0x8F,0xEF,0xFF,0xC0,
0x03,0x00,0x00,0x00,0x7F,0xF0,0x3C,0x00,0x00,0x0F,0x38,0xE7,0x8F,0xEF,0xFF,0xC0,
0x07,0x00,0x00,0x00,0x3F,0xE0,0x7C,0x00,0x00,0x0F,0x38,0xE3,0x8F,0xEF,0xFF,0xC0,
0x07,0x00,0x00,0x00,0x3F,0xE0,0x7C,0x00,0x00,0x07,0x00,0xE1,0x8F,0xEF,0xFF,0xC0,
0x07,0x00,0x00,0x00,0x1F,0xC0,0x7C,0x01,0xFE,0x01,0x00,0xE0,0x01,0x81,0xE0,0x00,
0x07,0x00,0x00,0x00,0x1F,0xC0,0x7C,0x01,0xFE,0x00,0x3F,0xFF,0x81,0x8F,0xFF,0xC0,
0x07,0x00,0x00,0x00,0x1F,0xC0,0x7C,0x00,0xFE,0x07,0x3F,0xFF,0x81,0x8F,0xFF,0xC0,
0x07,0x00,0x00,0x00,0x0F,0x80,0x7C,0x00,0x7E,0x07,0x03,0xF8,0x01,0x8F,0xFF,0xC0,
0x07,0x00,0x00,0x00,0x0F,0x80,0x7C,0x00,0x3E,0x07,0x03,0xF8,0x01,0x8E,0xEC,0xC0,
0x07,0x00,0x00,0x00,0x0F,0x80,0x7C,0x00,0x3E,0x07,0x07,0xF8,0x01,0x8E,0xEC,0xC0,
0x07,0x80,0x00,0x00,0x0F,0x80,0x3C,0x00,0x3E,0x07,0x07,0xF8,0x01,0xAE,0xEC,0xC0,
0x07,0xC0,0x00,0x00,0x0F,0x80,0x3E,0x00,0x3E,0x0E,0x0E,0xFC,0x01,0xEE,0xEC,0xC0,
0x07,0xE0,0x00,0x00,0x0F,0x80,0x1F,0x00,0x3E,0x0E,0x0E,0xFE,0x01,0xEE,0xEC,0xC0,
0x07,0xF0,0x00,0x00,0x0F,0x80,0x1F,0x80,0x3E,0x0E,0x0E,0xFE,0x01,0xEE,0xEC,0xC0,
0x03,0xF8,0x00,0x00,0x0F,0x80,0x0F,0xC0,0x3E,0x0E,0x3E,0xEF,0x01,0xEE,0xEC,0xC0,
0x01,0xFC,0x00,0x00,0x0F,0x80,0x07,0xFF,0xFE,0x1E,0x38,0xE7,0x8F,0x8E,0xEC,0xC0,
0x00,0xFF,0xFF,0x80,0x0F,0x80,0x03,0xFF,0xFE,0x18,0x30,0xE3,0x8F,0x0E,0xED,0xC0,
0x00,0x3F,0xFF,0x00,0x0F,0x80,0x01,0xFF,0xFC,0x18,0x20,0xE1,0x8E,0x0E,0xED,0xC0,
0x00,0x0F,0xFE,0x00,0x0F,0x80,0x00,0x7F,0xF8,0x10,0x20,0xE1,0x8E,0x0E,0xED,0xC0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
void Lcd_Clear(u8 color)
{
	u8 seg,page;

	for(page = 0xb0; page < 0xb9; page++) 	//page = 0xb0 ~ 0xb8
	{
		Lcd_WriteCommand(page);					//page address
		Lcd_WriteCommand(0x10);					//column address
		Lcd_WriteCommand(0x00);
		for(seg=0; seg<128; seg++)			//write data
		{
			Lcd_WritdData(color);
		}
	}
}

static void Lcd_Init(void)
{
//	Djy_EventDelay(120*mS);
//	Lcd_WriteSpecialCmd(0xe2);		//reset
	Djy_EventDelay(10*mS);

    Lcd_WriteCommand(0xAE);         	//1.将液晶屏的显示关掉
    Lcd_WriteCommand(0xA2);         	//11.设置偏压比1/9
    Lcd_WriteCommand(0xA0);         	//8.设置SEG 输出方向
    Lcd_WriteCommand(0xC8);         	//15.设置公共端输出扫描方向

//    Lcd_WriteSpecialCmd(0x26);        //17.调整V0电压 (1 + Rb/Ra) ratio 值，调整此值影响很大
    Lcd_WriteCommand(0x81);         	//18.开始设置EV亮度α的命令
    Lcd_WriteCommand(0x30);         	//18.设置α的值，值越大对比度越强，调整此值影响不太，是微调的
	Djy_DelayUs(200);
    Lcd_WriteCommand(0x2F);         	//16.开启所有相关电压
	Djy_DelayUs(200);
	Lcd_WriteCommand(0x40);   		//显示开始的第一行，为0即第一行
	Lcd_WriteCommand(0xb0);			// Page Address,Page 0
	Lcd_WriteCommand(0x10);			// Column Address,Column = 0
	Lcd_WriteCommand(0x00);
    Lcd_WriteCommand(0xAF);         	//1.将液晶屏的显示开启
    Lcd_WriteCommand(0xF8);         	//19.此两条命令是设置升压比到5X的
    Lcd_WriteCommand(0x01);
	Djy_DelayUs(500);                   //不知此延时可否省去，不过了安全起见，初次调试保留为好。。

}

static void MapToLCDFormat_128x8(u8 *dst,const u8 *src)
{
	int i;

	memset(dst,0,128);
	for(i=0;i<128;i+=8)
	{
		dst[0] |= src[0*16]&(1<<7)?(1<<0):0;
		dst[0] |= src[1*16]&(1<<7)?(1<<1):0;
		dst[0] |= src[2*16]&(1<<7)?(1<<2):0;
		dst[0] |= src[3*16]&(1<<7)?(1<<3):0;
		dst[0] |= src[4*16]&(1<<7)?(1<<4):0;
		dst[0] |= src[5*16]&(1<<7)?(1<<5):0;
		dst[0] |= src[6*16]&(1<<7)?(1<<6):0;
		dst[0] |= src[7*16]&(1<<7)?(1<<7):0;

		dst[1] |= src[0*16]&(1<<6)?(1<<0):0;
		dst[1] |= src[1*16]&(1<<6)?(1<<1):0;
		dst[1] |= src[2*16]&(1<<6)?(1<<2):0;
		dst[1] |= src[3*16]&(1<<6)?(1<<3):0;
		dst[1] |= src[4*16]&(1<<6)?(1<<4):0;
		dst[1] |= src[5*16]&(1<<6)?(1<<5):0;
		dst[1] |= src[6*16]&(1<<6)?(1<<6):0;
		dst[1] |= src[7*16]&(1<<6)?(1<<7):0;

		dst[2] |= src[0*16]&(1<<5)?(1<<0):0;
		dst[2] |= src[1*16]&(1<<5)?(1<<1):0;
		dst[2] |= src[2*16]&(1<<5)?(1<<2):0;
		dst[2] |= src[3*16]&(1<<5)?(1<<3):0;
		dst[2] |= src[4*16]&(1<<5)?(1<<4):0;
		dst[2] |= src[5*16]&(1<<5)?(1<<5):0;
		dst[2] |= src[6*16]&(1<<5)?(1<<6):0;
		dst[2] |= src[7*16]&(1<<5)?(1<<7):0;

		dst[3] |= src[0*16]&(1<<4)?(1<<0):0;
		dst[3] |= src[1*16]&(1<<4)?(1<<1):0;
		dst[3] |= src[2*16]&(1<<4)?(1<<2):0;
		dst[3] |= src[3*16]&(1<<4)?(1<<3):0;
		dst[3] |= src[4*16]&(1<<4)?(1<<4):0;
		dst[3] |= src[5*16]&(1<<4)?(1<<5):0;
		dst[3] |= src[6*16]&(1<<4)?(1<<6):0;
		dst[3] |= src[7*16]&(1<<4)?(1<<7):0;

		dst[4] |= src[0*16]&(1<<3)?(1<<0):0;
		dst[4] |= src[1*16]&(1<<3)?(1<<1):0;
		dst[4] |= src[2*16]&(1<<3)?(1<<2):0;
		dst[4] |= src[3*16]&(1<<3)?(1<<3):0;
		dst[4] |= src[4*16]&(1<<3)?(1<<4):0;
		dst[4] |= src[5*16]&(1<<3)?(1<<5):0;
		dst[4] |= src[6*16]&(1<<3)?(1<<6):0;
		dst[4] |= src[7*16]&(1<<3)?(1<<7):0;

		dst[5] |= src[0*16]&(1<<2)?(1<<0):0;
		dst[5] |= src[1*16]&(1<<2)?(1<<1):0;
		dst[5] |= src[2*16]&(1<<2)?(1<<2):0;
		dst[5] |= src[3*16]&(1<<2)?(1<<3):0;
		dst[5] |= src[4*16]&(1<<2)?(1<<4):0;
		dst[5] |= src[5*16]&(1<<2)?(1<<5):0;
		dst[5] |= src[6*16]&(1<<2)?(1<<6):0;
		dst[5] |= src[7*16]&(1<<2)?(1<<7):0;

		dst[6] |= src[0*16]&(1<<1)?(1<<0):0;
		dst[6] |= src[1*16]&(1<<1)?(1<<1):0;
		dst[6] |= src[2*16]&(1<<1)?(1<<2):0;
		dst[6] |= src[3*16]&(1<<1)?(1<<3):0;
		dst[6] |= src[4*16]&(1<<1)?(1<<4):0;
		dst[6] |= src[5*16]&(1<<1)?(1<<5):0;
		dst[6] |= src[6*16]&(1<<1)?(1<<6):0;
		dst[6] |= src[7*16]&(1<<1)?(1<<7):0;

		dst[7] |= src[0*16]&(1<<0)?(1<<0):0;
		dst[7] |= src[1*16]&(1<<0)?(1<<1):0;
		dst[7] |= src[2*16]&(1<<0)?(1<<2):0;
		dst[7] |= src[3*16]&(1<<0)?(1<<3):0;
		dst[7] |= src[4*16]&(1<<0)?(1<<4):0;
		dst[7] |= src[5*16]&(1<<0)?(1<<5):0;
		dst[7] |= src[6*16]&(1<<0)?(1<<6):0;
		dst[7] |= src[7*16]&(1<<0)?(1<<7):0;

		dst += 8;
		src += 1;

	}

}


static char lcd_buf[128];

static void lcd_draw_bitmap(const u8 *src)
{
	int x,y,page;
	u8 *dst;
	bool_t result;

	result = Lock_SempPend(pLcdCtrlSync,5*mS);
	if(result == true)
	{
		page =0xb0;									//page start address
		for(y=0;y<64;y+=8)
		{
			MapToLCDFormat_128x8((u8*)lcd_buf,src);
			Lcd_WriteCommand(page);					//page address
			Lcd_WriteCommand(0x10);					//column address
			Lcd_WriteCommand(0x00);

			dst =(u8*)lcd_buf;
			for(x=0;x<128;x+=8)
			{
				Lcd_WritdData(*dst++);
				Lcd_WritdData(*dst++);
				Lcd_WritdData(*dst++);
				Lcd_WritdData(*dst++);
				Lcd_WritdData(*dst++);
				Lcd_WritdData(*dst++);
				Lcd_WritdData(*dst++);
				Lcd_WritdData(*dst++);
			}

			page++;
			src += 128;
		}
		Lock_SempPost(pLcdCtrlSync);
	}
}

// =============================================================================
// 功能：调节屏幕的对比度
// 参数：对比度值,初始化时默认正常情况为CN_CONTRAST_DEFAULT
// 返回：无
// =============================================================================
void Lcd_ContrastAdjust(u8 Value)
{
	bool_t result;
	s8 EV = 0x30;			//微调对比度，默认为0x30,最大值为0x3F，最小值为0
	u8 EV_Level = 50;		//对比度参考值，假设默认vop = 0x30时，EV_Level = 50

	EV = (Value - EV_Level) + EV;

	result = Lock_SempPend(pLcdCtrlSync,5*mS);
	if(true == result)
	{
		if(EV > 0x3F)
			EV = 0x3F;
		else if(EV < 0)
		{
			EV = 0;
		}
		Lcd_WriteCommand(0x81);			// Set EV
		Lcd_WriteCommand( EV );
		Lock_SempPost(pLcdCtrlSync);
	}
}

void ModuleInstall_LCD(void)
{
	Lcd_PortInit();

	Lcd_Init();

	pLcdCtrlSync = Lock_SempCreate(1,1,CN_SEMP_BLOCK_FIFO,NULL);

	if(NULL != pLcdCtrlSync)
		lcd_draw_bitmap(g_byIcon_szn);
//	while(1)
//	{
//		Djy_EventDelay(500*mS);
//	}
}

// =========================================================================
// 函数功能：LCD背光控制
// 输入参数：byCtrl 输入参数 0=关闭背光 非0=开背光
// 输出参数：
// 返回值  ：
// =========================================================================
void Lcd_SetBackLight(uint8_t byCtrl)
{
    if (0==byCtrl)
    {
        PIO_Set(&LCD_Pins[5]);
    }
    else
    {
        PIO_Clear(&LCD_Pins[5]);
    }
}

// =============================================================================
// 功能：显示整屏数据，对应用层提供了完整的接口，但是实际上该函数只用于显示整屏数据
// 参数：
// 返回：无
// =============================================================================
void Lcd_wrDISPram(uint32_t dwleft,uint32_t dwtop,uint32_t dwsize,uint8_t * pbysrcadd)
{
//    uint32_t dwloopi, dwposi;
//    uint8_t byposil, byposih;
//
//    dwposi = dwleft + dwtop * (CN_LCD_XSIZE/8);
//    byposih = (uint8_t )(dwposi >> 8);
//    byposil = (uint8_t )(dwposi & 0xff);
//    Lcd_WriteCmd(byposil, byposih,CN_6963_SET_ADDRESS);
//    Lcd_WriteCmd(0,0,CN_6963_SET_AUTO_WRITE);
//
//    for(dwloopi=0;dwloopi < dwsize;dwloopi++)
//    {
//        Lcd_WriteData(pbysrcadd[dwloopi]);
//    }
//    Lcd_WriteCmd(0,0,CN_6963_EXIT_AUTO_WRITE);
	lcd_draw_bitmap(pbysrcadd);
}

#endif
